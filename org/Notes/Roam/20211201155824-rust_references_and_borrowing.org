:PROPERTIES:
:ID:       ab8bd989-c7d8-4445-b773-c4af5517baf6
:END:
#+title: Rust-References-And-Borrowing
* How To Reference A Variable
If we have a variable that we need to retain ownership of for future use after a function call we can reference it when we pass it to the function using the & operator, as so
#+begin_src rust
  let s1 = String::from("hello");

  let len = calculate_length(&s1); // reference to s1

  fn calculate_length(s: &String) -> usize {} // reference type String
#+end_src
When we are passing in a variable by reference we nee to inform the function that it will not take ownership of the argument, this can be seen by the &String type attached to the s argument for the calculate_length function. This means that the function can use the value but as it does not own it, it can not drop it when the reference stops being used.

* Borrowing
The process of passing a variable via reference borrowing, it can be though of as the process of borrowing something off a friend, you never actually own the item, they do, you just borrowed it to perform some task.

As borrowing does not produce a copy of the data on the heap the reference points to, we can not modify the value, similar to variables, they are immutable by default.

However we can pass a reference as a mutable reference, as so
#+begin_src rust
  let mut s = String::from("hello"); // Assign as mut var

  change(&mut s); // Pass as mut reference

  fn change(some_string: &mut String) {} // Type of mut reference String
#+end_src
Here we can see that we defined the variable as mutable, passed as mutable reference to the function, which accepts a mutable reference type as argument. You can only have one mutable reference open at a time, having two will result in a data race will throw a compile error, as we want to avoid undefined behavior that can occur when we have multiple places accessing and writing to a pointer at the same time. This is also the case when mixing immutable references with mutable reference on the same variable.

