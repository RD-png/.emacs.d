:PROPERTIES:
:ID:       57a80043-7d03-477b-879a-cf6d6e51ab49
:END:
#+title: Rust-Method-Syntax
Method syntax is not to be confused with standard functions, methods are defined within the context of a struct or enum or trait. They always take the keyword self as their first parameter. This is a similar concept to defining a function on a model class which uses the class properties at the time the function is called.

* Defining Methods
An example provided in the guide gets us to implement a function called area which takes a single argument Rectangle, however it points out that we could define it using method syntax, as so

NOTE: impl methods are associated with a struct, so the names should match
#+begin_src rust
  impl Rectangle {
      fn area(&self) -> u32 {
          self.width * self.height
      }
  }
#+end_src
We can access this method on a struct instance of Rectangle using dot notation, as so
#+begin_src rust
  rectangle1.area()
#+end_src
This allows us to group functionality to a struct (type), meaning we can define multiple methods called area for different structs, for example we could have a struct called Circle which has impl block which has a method called area, we can use these on the respected types without confusion or the need to create separate names for the functionality.

** Multiple Impl Blocks
We can define multiple impl blocks for a struct, we generally would use this with a combination of generic types and traits, by itself it doesnt offer much and may confuse other programmers.

* Associated Functions
These are still defined with the context of a struct, however they do not take the instance of the struct as an argument and therefore are functions, rather than methods.
An example would be a function named square defined on the Rectangle implementation. For example
#+begin_src rust
  fn square(size: u32) -> Rectangle {
      Rectangle {
          width: size,
          height: size,
      }
  }
#+end_src
This would produce a rectangle with the same height and width, a square. We should call associated functions differently than methods, we can use the :: notation, which we also use for namespaces.
#+begin_src rust
  let sq = Rectangle::square(3);
#+end_src

* Summary
Essentially allow us to create custom types for groups of data we want to distinguish as a type for readability. This is not the only method of creating custom types we can also use [[id:3339f75f-a28a-4c1c-b943-64f717d4e672][Enums]].
