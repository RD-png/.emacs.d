:PROPERTIES:
:ID:       12e18796-f0d0-449f-bdfa-15d1d5383334
:END:
#+title: Iterative-Vs-Recursive

* Recursion
The repeated application of a recursive procedure or definition.

* Iteration
Repetition of a mathematical or computational procedure applied to the result of a previous application, typically as a means of obtaining successively closer approximations to the solution of a problem.

* Why to choose on over the other
Often a recursive solutions are generally more expressive, more closely resembling a mathematical formula, where as an iterative solution is generally comparable to a list of instructions.

Independent of language the choice between the two comes down to how the programmer approaches the problem both can produce clean solutions, arguably recursive implementations are more concise and align more with mathematical problems, whereas iterative solutions generally required more code and generally explain how to produce rather than express a solution. For example the following implementations of the fibonacci sequence.

** Recursive
This is a rather simple implementation, which closely resembles the mathematical representation of the fibonacci sequence.
#+begin_src scheme
  (define fib
    (lambda (n)
      (cond ((= n 0) 0)
            ((= n 1) 1)
            (else (+ (fib (- n 1)) (fib (- n 2)))))))
#+end_src

** Iterative
As scheme does not have a looping primitive I will write it in c. Clearly this implementation is not as readable as the recursive solution, however it will perform better for larger values of n.
#+begin_src c
  int fib(int n) {
    int curr = 0;
    int next = 1;
    int res = 0;

    for (int i = 0; i < n; i++) {
      res = curr + next;
      curr = next;
      next = res;
    }

    return curr;
  }
#+end_src

** Comparison
While the reclusive implementation offers are cleaner and easier to read procedure, there are fundamental issues with its performance, as n grows it begins to operate significantly slower then the iterative implementation due to the growing stack calls that need to be executed. Whereas the iterative versions stack does not grow.

** Solution - Tail Recursion.
While its not a necessarily a solution, if we desired the readability of the recursive solution with the performance of the iterative implementation, we can opt for a sort of hybrid approach.

** Tail Recursive
Known as tail recursive as at the tail of the expression it calls itself, similar to a recursive function, however the stack remains the same size regardless of n, by passing the required state via recursive calls to the iter producer. This avoid defining and mutating state and produces not side effects, therefore many people would find this to be the desirable implementation.
#+begin_src scheme
  (define fib
    (lambda (n)
      (define iter
        (lambda (curr next n)
          (if (= n 0)
              curr
              (iter next (+ next curr) (- n 1)))))
      (iter 0 1 n)))
#+end_src




