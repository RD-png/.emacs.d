:PROPERTIES:
:ID:       fe72f238-59e8-4a49-a03f-fc57d80583a0
:END:
#+title: scheme-lets

* let
The simplest of the let types, allows for locally bound variables. As the example below shows we are able to bind a value to the variable a then use that variable within the scope of the let expression.
#+begin_src scheme
  (define example
    (lambda (x)
            (let ((a (* x x)))
              a)))
  (example 2) ;-> 4
#+end_src

* let*
This evaluates bindings in sequence, so that variables can be used in the definition of other variables. This is a syntax sugar for nested let expressions. For example the following two statements produce the same result.
#+begin_src scheme
  (let* ((a 1)
         (b (* a 2))
         (c (+ b a)))
    (list a b c))

  (let ((a 1))
    (let ((b (* a 2)))
      (let ((c (+ b a)))
        (list a b c))))
#+end_src

* letrec
letrec, on the other hand, allows you to bind recursive values. So you might write a recursive function that you only want to be within the function scope and bind it to a name using letrec.
#+begin_src scheme
  (letrec ((sum (lambda (ls)
                  (if (null? ls)
                      0
                      (+ (car ls) (sum (cdr ls)))))))
    (sum '(1 2 3 4 5)))
#+end_src
