:PROPERTIES:
:ID:       9eb54542-4be9-477d-8477-8d8a12d4f623
:END:
#+title: Lambda-Expressions

A lambda expression evaluates to a procedure. The environment in effect when the lambda expression is evaluated is remembered as part of the procedure, this is known as the closing environment.

When the procedure is later called with some arguments, the closing environment is extended by binding the variables in the formal parameter list to fresh locations, and the locations are filled with the arguments according to rules about to be given. The new environment created by this process is referred to as the invocation environment.

* Lambda Usage
Often we may want to use a lambda expression while in a scope inside a function, however we do not wish to name the function or declare it globally. For example when using map
#+begin_src scheme
  (map (lambda (x) (+ x x)) (list 1 2 3))
#+end_src

** Named Lambda and Lambdas Bound In Let
There is very little difference between the next three
#+begin_src scheme
  (define double
    (lambda (x)
      (+ x x)))

  ;; Named lambda defined in the scope of a let
  (let ((double (lambda (x) (+ x x))))
    (double 2))
#+end_src
The second representation allows for definition inside the scope of a let, which is often useful when we do not wish to define something globally or even within the whole scope of a procedure, only where is necessary.

We may often define a lambda inside nested lets as this allows us to produce some interesting design patterns. For example, this demonstrates the closing environment, the free variable x is bound to the lambda expression and we are able to use it outside of the scope of the original x variable binding, we are even able to introduce another x variable which does not effect the lambda as its environment is closed.
#+begin_src scheme
  (let ((f (let ((x 'sam))
             (lambda (y z) (list x y z))))) ;; Scope for the let that defines x closes
    (let ((x 'not-sam)) ;; Defined a new x value inside a new let
      (f 'i 'am))) ; -> (sam i am), uneffected due to closing enviroment
#+end_src
Incidentally, a let expression is nothing more than the direct application of a lambda expression to a set of argument expressions. For example, the two expressions below are equivalent. As it is a syntax sugar to allow for a cleaner representation of the lambda expression, similarly to define and name lambda expressions mentioned above.
#+begin_src scheme
  (let ((x 'a)) (cons x x)) === ((lambda (x) (cons x x)) 'a)

  ;; You see the point, same as below
  (let ((x 'a) (y 'b)) (cons x y))

  ((lambda (x y) (cons x y)) 'a 'b)
#+end_src

* Lambda Parameters
It is not a very common use case but this syntax is the same and is something to be aware of.
#+begin_src scheme
  (let ((f (lambda x x)))
    (f 1 2 3 4))

  (let ((f (lambda (#!rest x) x)))
    (f 1 2 3 4)) 
#+end_src
Where the first representation shows the x argument with no . or #!rest identifier it will still bind to all the argument passed to the procedure, I prefer to use the 2nd representation as it makes it far clearer when a list of arguments will be passed.

* Define vs Defun Syntax
The following are two ways of defining a top level procedure.
#+begin_src scheme
  ;; This is syntax sugar for below
  (define (double x)
    (+ x x))

  ;; This operates exactly as the same as above
  (define double
    (lambda (x) (+ x x)))
#+end_src
While the first is basically syntax sugar for second representation there is a subtle difference in how they operate. For example
#+begin_src scheme
  ;; Define procedure that produces a compound-procedure
  (define (compose p1 p2)
    (lambda (x)
      (p1 (p2 x))))

  ;; If we define a procedure using this syntax we cannot bind values to the compound
  (define (cadr) (compose car cdr))

  (cadr '(1 2)) ;-> error expected 0 Parameters

  ;;  ---------------------------------------------------------------------------------------

  ;; Define procedure that produces a compound-procedure
  (define compose
    (lambda (p1 p2)
      (lambda (x)
        (p1 (p2 x)))))

  ;; However this will work as it allows us to bind to the compound-procedure
  (define cadr (compose car cdr))

  (cadr '(1 2)) ;-> 2
#+end_src
Just be aware of this, when defining procedures that bind to a compound-procedure we should use the defun syntax, however use define syntax otherwise. For example
#+begin_src scheme
  ;; Define syntax
  (define (compose p1 p2)
    (lambda (x)
      (p1 (p2 x))))

  ;; Defun syntax
  (define cadr (compose car cdr))

  (cadr '(1 2)) ;-> 2
#+end_src
As this is useful as a hint that we are defining something that is bound to the scope of compound-procedure.
